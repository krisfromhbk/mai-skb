// Объявление констант (не меняются по ходу программы)
// Задавать подобным образом рекомендуется. Если надо поменять пин, то это делается только здесь
// p.s. чуть позже мы еще изменим алгоритм, чтобы для общения использовать 6 проводов, а не 12

// Немного про названия переменных для пинов:
// Формат названия в нашем случае:
//   - f1 и f2 - обозначения плат, чтобы по одному названию переменной было понтно, с какой платой дальше работаем
//     p.s. это сделано исключительно для понимания кода
//   - RX и TX означают соответственно, что этот пин используется в приеме, отправке данных
//     p.s. R от receive, T от transmit
//   - C, R и D:
//     C - такт, по переднему фронту которого принимающая сторона считывает биты
//     R - пин, сигнализирующий о готовности принимающей стороны принимать данные
//     D - пин, по которому последовательно передаются биты информации (и у него есть еще небольшая функция)
//     p.s. протокол лучше объяснять вживую
//     update: некоторые детали протокола поясняются ниже по ходу комментирования

#define f1_RX_C 1
#define f1_RX_D 2
#define f1_RX_R 10

#define f1_TX_C 9
#define f1_TX_D 8
#define f1_TX_R 0

#define f2_RX_C 4
#define f2_RX_D 5
#define f2_RX_R 7

#define f2_TX_C 6
#define f2_TX_D 5
#define f2_TX_R 3
// Закончили с объявлением констант 

// Функция для "поправки" при получении сигнала с платы ESP32. Она выдает на свои контакты максимум 3.3 вольта
// Принимает на вход номер пина, возвращает true или false в зависимости от условия
boolean digitalGluk(int pin) {
  // Функция analogRead встроена в прошивку Arduino. Возвращает значение от 0 до 1023 в зависимости от напряжения на пине
  // сравнивая значение с 312 мы буквально говорим "Нас устраивает напряжение больше 1.5 вольт"
  // p.s. полтора вольта получаются, если логическую единицу Ардуинки (5 вольт) поделить на отношение 1020 к 312
  if (analogRead(pin) > 312) {
    // Если на пине больше 1.5 вольт, значит нам что-то пришло на этот пин
    return true; 
  } else { 
    // Если нет (как правило там вообще возможны 0, 3.3 и 5 вольт), то возвращаем false
    // буквально "На этом пине сейчас нет ничего"
    return false;
  }
}

// Втроенная в прошивку Arduino функция для настройки перед непосредственной работой в постоянном цикле
void setup() {
  // Выставляем режими работы пинов
  pinMode(f1_TX_C, OUTPUT);
  pinMode(f1_TX_D, OUTPUT);
  pinMode(f1_RX_R, OUTPUT);

  pinMode(f2_TX_C, OUTPUT);
  pinMode(f2_TX_D, OUTPUT);
  pinMode(f2_RX_R, OUTPUT);

  // Тут не хватает описания ещё шести пинов для получения информации
  // с такой конфигурацией пока эта прошивка должна уметь только отправлять данные
  // p.s. дописываем, чтобы можно было еще и получать информацию с других плат:
  pinMode(f1_RX_С, INPUT);
  pinMode(f1_RX_D, INPUT);
  pinMode(f1_TX_R, INPUT);

  pinMode(f2_RX_С, INPUT);
  pinMode(f2_RX_D, INPUT);
  pinMode(f2_TX_R, INPUT);

  // Инициализируем последовательное соединение (с компьютером) и указвыаем скорость передачи данных (бит/с)
  Serial.begin(9600);
}

// Функция для получения данных с платы, к которой мы подключаемся через пины с префиксом "f2"
// Она ничего не принимает, только возвращает переменную типа Byte,
// содержащую код конкретного символа (в шестнадцатиричном виде)
// p.s. в основном цикле мы автоматически преобразуем byte к char и получим символ по его коду
// p.s.s например, для латинской буквы A код 41 (в шестнадцатиричном виде)
byte receive2() {
  // Заводим переменную, куда будем собирать все биты присылаемого нам байта
  // p.s. по протоколу, после некоторых приготовлений и обмена любезностями между платами
  // плата-отправитель последовательно, с задержкой в 1 секунду отправит 8 бит того самого кода буквы
  // (уже в бинарном виде)
  // https://www.rapidtables.com/convert/number/ascii-to-binary.html - это ascii -> bin конвертер
  // hex-значения конкретных символов можно глянуть в ascii-таблицах
  byte prishlo = 0;

  // Тот самый обмен любезностями
  // По протоколу, чтобы плата-отправитель отправила плате-приемнику какие-то данные,
  // предварительно она (отправитель) должна на своем пине TX_D выставить логическую единицу (HIGH)
  // Значит, если на нашей плате-приемнике на пине RX_D появляется единица - это сигнал к началу приема данных для нас
  // конструкция if дальше и проверяет выполнение этого условия с поправкой на возможные 3.3 вольта,
  // используя функцию digitalGluk()
  if (digitalGluk(f2_RX_D)) {
    // Далее по протоколу, когда наша плата-приемник поняла, что ей собираются передать данные,
    // она выставляет пин RX_R в логическую единицу
    // Это прямой сигнал плате-отправителю начать отправку данных (будет видно в функции отправки)
    digitalWrite(f2_RX_R, HIGH); 
    
    // Цикл для обработки приходящих нам битов (оч мудреный на первый взгляд)
    // p.s. для начала краткий экскурс в понятие "Битовый сдвиг", на нем основан дальнейший код
    // пусть у нас есть какая-то переменная типа byte (8 бит) с значением 00001111
    // если я хочу сдвинуть все биты нашей переменной влево на 1 позицию,
    // то у нас выйдет 00011110, наши четыре единицы сдвинулись влево на одну позицию
    // есть еще сдвиг вправо, принип тот же, но он используется в функции отправки
    // И так, начинаем цикл, используем for, т.к. нам заранее известно, что принимать мы будем ровно 8 бит
    // p.s. по классике считаем от 0 xD
    for (int i = 0; i < 8; i++) {
      // По протоколу, мы ждем пока на пине RX_C состояние не сменится с нуля на единицу
      // т.е. в начальный момент времени на пине RX_C ноль,
      // когда плата-отправитель хочет нам отправить один бит, она сначала выставляет на своем пине TX_D значение этого бита,
      // а затем дает плате-приемнику понять, что вот этот конкретный бит можно принимать.
      // Для этого она (плата-отправитель) меняет состояние своего пина TX_C с нуля на единицу
      // мы же в функции приема ждем этого изменения циклом while
      // таким образом, пока на плата-отправитель не выставит у себя единицу (которую мы тут же словим у себя),
      // мы все это время ждем этого изменения, "болтаясь" в пустом теле цикла while
      while (!digitalGluk(f2_RX_C)) {
        // тупа чилим с пацанами
      }
      // По протоколу, как только состояние на нашем RX_C изменится с нуля на единицу, 
      // мы должны прочитать с пина RX_D текущий бит (помним, что в рамках этого цикла for мы принимаем 8 бит)
      // а делаем мы это довольно хитро, сейчас у нас есть объявленная переменная prishlo,
      // в которой изначально были записаны 8 нулей (00000000).
      // Вспоминаем про битовые сдвиги... Здесь они записываются через оператор "<<" (влево) и ">>" (вправо)
      // после которого указывается, на сколько мы сдвигаем биты в переменной, итого получается "переменная << сдвиг".
      // По проходу восьми таких сдвигов, все отвправленные по очереди биты с платы-отправителя
      // образуют у нас на плате-приемнике в переменной prishlo то же значение, что и отправлялось
      // по сути мы передали 8 бит информации, используя один провод
      prishlo = prishlo | ( digitalGluk(f2_RX_D) << i );
      while (digitalGluk(f2_RX_C)) {
        // продолжаем чилить, пока RX_C не станет нулем
        // p.s. фе, такие себе выражения конечно
      }
    }

    // По протоколу, когда мы как плата-приемник закончили принимать все 8 бит,
    // выставляем свой RX_R обратно в ноль
    digitalWrite(f2_RX_R, LOW);
  }
  // Возвращаем полученный байт информации (один символ)
  return prishlo;
}

// Аналогичная функция, но принимающая информацию с другой тройки пинов (для общения с другой платой, префикс "f1")
byte receive1(){
  byte prishlo = 0;

  if (digitalGluk(f1_RX_D)) {
    digitalWrite(f1_RX_R, HIGH);

    for (int i=0; i<8; i++) {
      while (!digitalGluk(f1_RX_C)) {}
      prishlo = prishlo|(digitalGluk(f1_RX_D)<<i);
      while (digitalGluk(f1_RX_C)) {}
    }
    
    digitalWrite(f1_RX_R, LOW);
  }
  return prishlo;
}

// Функция для отправки данных на плату, к которой мы подключаемся через пины с префиксом "f2"
void otpr2(byte pispis) {
  // По протоколу, перед отправкой, оповещаем плату-приемник о своем намерении отправить данные.
  // Выставляем свой TX_D в единицу (можешь глянуть, что именно на единицу на RX_D в функции приема
  // должна триггерится плата-приемник)
  digitalWrite(f2_TX_D, HIGH);
  // По протоколу, ожидаем, пока плата-приемник не "скажет", что готова принимать информацию
  // опять же, отсылаюсь к функции приема данных
  while (!digitalGluk(f2_TX_R)) {
    // ничего не делаем, пока на нашем TX_R (соответственно на отправляющей плате - RX_R) не появится единица
  }
  // Сбрасываем состояние пина TX_D, дальше он будет использоваться для отправки данных
  digitalWrite(f2_TX_D, LOW); 
  // Цикл for, 8 раз отправим текущий бит
  // (в то время как принимающая плата будет 8 раз принимать биты)
  for (int i = 0; i < 8; i++) {
    // По протоколу, при передаче непосредственного бита, первым делом выводим его значение в пин TX_D
    // p.s. тут снова это колдунство с битовыми сдвигами, но уже вправо
    // p.s.s. чтобы лучше понять эту магию, можно самостоятельно (или вместе) потыкать битовые сдвиги,
    // написать пару тестовых программ
    digitalWrite(f2_TX_D, 1 & (pispis >> i));
    // Сменяем состояние своего пина TX_C с нуля на единицу
    // т.е. триггерим плату-приемник, что бит на нашем пине TX_D (соответственно на RX_D у платы-приемника)
    // записан, и его надо забрать в переменную prishlo
    digitalWrite(f2_TX_C, HIGH);
    // Толерантная задержечка в секунду, чтобы плата-приемник наверняка приняла бит
    delayMicroseconds(1000);
    // Выставляем свой TX_C в ноль, плата-приемник реагирует на это как-то так:
    // "Оп, тот бит закончили принимать, ждем следующий"
    digitalWrite(f2_TX_C, LOW);
    // Еще одна толерантненькая задержечка, после которой продолжаем цикл передачи битов
    // p.s. напоминаю, что у нас все это время были 8 бит кода символа
    delayMicroseconds(1000);
  }
  // Когда закончили передавать все биты, выставляем свой TX_D в ноль
  digitalWrite(f2_TX_D, LOW); 
}

// Аналогичная функция но для отправки по пинам с префиксом "f1"
void otpr1(byte pispis) {
  digitalWrite(f1_TX_D, HIGH);
  while (!digitalGluk(f1_TX_R)) {} 
  digitalWrite(f1_TX_D, LOW); 
  for (int i=0; i<8; i++) {
    digitalWrite(f1_TX_D, 1&(pispis>>i));
    digitalWrite(f1_TX_C, HIGH);
    delayMicroseconds(1000);
    digitalWrite(f1_TX_C, LOW);
    delayMicroseconds(1000);
  }  
  digitalWrite(f1_TX_D, LOW); 
}

// Основной цикл ардуинки, все что в нем есть выполняется постоянно
void loop() {
 
  // Заводим переменную, в которую записываем присланный символ с платы с префикосм "f1"
  // тут как раз и сработает преобразование byte к char и мы увидем не hex-код символа, а сам символ
  char dvar = receive1();
  // Простенькая проверочка, что нам реально что-то пришло
  if (dvar > 0) {
    // Таки если пришло, выводим в "монитор"
    Serial.print(dvar);
    // Отправляем на плату с префиксом "f2" принятый с "f1" символ
    otpr2(dvar);
  }

  // Аналогично предыдущей конструкции, но не объявляем переменную, а используем уже имеющуюся,
  // принимаем с "f2", выводим у себя, отправляем на "f1"
  dvar = receive2();
  if (dvar>0) { 
    Serial.print(dvar); 
    otpr1(dvar);
  }
  
  // Объявляем переменную в которую считываем введенное нами с клавиатуры значение
  // p.s. в нашем случае с клавиатуры
  char a = Serial.read();
  // Если что-то ввели, отправляем на "f1" и "f2"
  if (a > 0) { 
    otpr1(a); 
    otpr2(a);
  }
  
  // Небольшая задержка
  delay(10);
}
